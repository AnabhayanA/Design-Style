<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Examples — Material Pixel</title>
<link rel="stylesheet" href="style.css">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
</head>
<body>

<header class="app-bar elevation-4">
  <div class="container row-between">
    <div class="brand">
      <img src="assets/md-widgets.svg" class="logo" alt="logo">
      <span class="site-title">Pixel Material</span>
    </div>
    <nav class="main-nav">
      <a href="index.html">Home</a>
      <a href="material-style-guide.html">Style Guide</a>
      <a href="about.html">About</a>
    </nav>
  </div>
</header>

<main class="container section">
  <h1 class="section-title animate">Component Examples</h1>
  <div class="cards grid-3">
    <div class="card animate delay-1 ripple">
      <img src="assets/md-components.svg" alt="Buttons">
      <h3>Buttons</h3>
      <p>Primary, secondary, and icon buttons with ripple and elevation.</p>
    </div>
    <div class="card animate delay-2 ripple">
      <img src="assets/md-elevation.svg" alt="Cards">
      <h3>Cards</h3>
      <p>Cards use rounded corners and layered shadows to separate content visually.</p>
    </div>
    <div class="card animate delay-3 ripple">
      <img src="assets/md-widgets.svg" alt="Widgets">
      <h3>Widgets</h3>
      <p>Chips, chips with icons, interactive lists, and other Material widgets.</p>
    </div>
  </div>
</main>

<a href="#hero" class="fab elevation-6 ripple" aria-label="Back to top">↑</a>

<footer class="footer elevation-2">
  <div class="container">
    <p>&copy; 2025 Pixel Material</p>
  </div>
</footer>

<script>
  const io = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (!e.isIntersecting) return;
      const target = e.target;
      if (target.classList && target.classList.contains('stagger')) {
        Array.from(target.querySelectorAll('.animate')).forEach((child, i) => {
          child.style.setProperty('--stagger-index', i);
          child.classList.add('visible');
        });
      } else {
        target.classList.add('visible');
      }
    });
  }, { threshold: 0.22 });
  document.querySelectorAll('.animate').forEach(el => io.observe(el));
  document.querySelectorAll('.ripple').forEach(el => {
    el.addEventListener('click', function (ev) {
      const span = document.createElement('span');
      span.className = 'ripple-effect';
      this.appendChild(span);
      const rect = this.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height);
      span.style.width = span.style.height = size + 'px';
      span.style.left = (ev.clientX - rect.left - size/2) + 'px';
      span.style.top = (ev.clientY - rect.top - size/2) + 'px';
      setTimeout(() => span.remove(), 300);
    });
  });
</script>

</body>
</html>
